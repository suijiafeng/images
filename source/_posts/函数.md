title: 函数
author: suijiafeng
tags: []
categories: []
date: 2017-03-17 01:28:00
---
## 为什么要使用函数，使用函数的目的 
1 程序有的时候一段一样的代码会在不同的地方多次执行，如果我们使用复制粘贴的方法，当然也可行，但是会造成**代码冗余**的情况发生，**可维护性也差**，你想啊，我一个地方改了，其他地方也要改，不能起到牵一发而动全身的效果。代码的健壮性也不好。
    
## 什么时候使用函数

    1.有些代码在不同地方，需要执行，我们可以把这些代码封装成一个函数。
    2.代码复用：如果一段代码是实现一个功能，我们就可以把一段代码封装成一个函数，哪里需要这个功能，就调用这个函数。
    
    函数是一块JavaScript中的一段代码，被定义一次，但是可执行和调用多次。
    JS中的函数也是对象，所以JS函数可以像其它对象那样操作和传递，所以我们也常把函数叫做函数对象。
    

## 函数名
    函数名最好为一个有意义的名词。
    js中函数不能重名，如果重名的会话，后面的函数会把前面的函数给覆盖掉。


## 函数体
    只要是符合js语法规范的代码，就可以称之为函数体。

## 函数名和变量名重名的情况
- 如果变量有值，那么输出的就是标量的值
- 如果变量没有值，那么输出的就是函数的代码，注意是函数的代码，而不是输出的结果。
- 建议：变量量名最好为一个有意义的动词，函数名最好为一个有意义的名词。


## 函数的参数
    - 形参
        定义函数的时候，在小括号里面写的，叫做函数的形式参数(形参);
        形参本质上就是函数声明中的一个变量
    - 实参
        调用函数的时候，小括号里面的值，调用的时候，会把实参传递给形参。
## 函数参数的类型
    - 值类型 它里面存放的是一个值
    - 引用类型 存放的是一个地址

## arguments
  - 是一个伪数组，里面存放的是实际是函数的参数。里面的元素和形参一一对应。
  - 因为是个伪数组，所以没有数组里面的方法，可以使用下标索引
  - 如果函数里面没有形参，函数调用的时候传递过来了实参，那么这个传递过来的值就存在arguments里面
    
## 重载
 - arguments 可以模拟重载。
 - 好处：a 方便程序员记忆，b 可以根据参数个数的不同，执行不同的代码。


## 返回值
    - return语句，函数在执行完return语句后，就会停止执行并立即退出程序。
    - 只能返回一个东西，如果想要返回多个东西的话，可以定一个个对象或者数组，以他们为载体返回。
    - 函数有retrun 语句并且有表达式；返回的是表达式的值。
    - 函数有return语句但是没有表达式；返回的是undefine。
    - 函数没有return ；返回的是undefined。
    

## 函数--作用域
-  在js当中只有函数能够划分作用域。函数在js 中也是一等公民。<br>
    a  局部作用域：任何函数的内部我们称之为局部作用域。
    b 全局作用域：script 标签内部我们称之为全局作用域。
-  作用域的访问规则：
    **就近原则**：
       1 使用一个变量。
            先去当前作用域去找，找到就使用，如果找不到就往父级找，父级没有？那再往上找，如果全局中也没有，那么报错。
       2  修改一个变量的值
            先去当前作用域找，如果有这个变量，那么把当前作用域中的变量的值给修改了；如果没有那么就往上找，如果都没有，那么它自己也就变成了一个全局变量。

## 预解析
-  在每个作用域里面的代码执行之前，都会把当前这个作用域里面**函数声明、变量**提升到**当前这个作用域的最顶端**，赋值语句保留在原地。

    注意关键字：的那你去哪作用域  函数声明 变量


## 函数的声明方式：

- 函数声明语句的方式声明函数
- 函数表达式的方式声明函数
两者的区别:<br>a 表达式在预解析阶段函数会被前置，提升但当前作用域；意味着不能立即调用。<br>
b 表达式声明的函数，函数不会前置，意味着可以立即调用。
 
## 函数的调用
- 函数名代表的是整个函数，函数名加个小括号，表示的是函数的调用，


## 函数的检测
- typeof 函数名
- 函数名 instanceof Function
- Object.prototype.toString.call(函数名)

## 函数的创建方法



## 函数调用的方式
 1. 直接调用
 2. 作为方法调用
 3. 函数上下文调用
 4. 构造器
 
 

## this
在JavaScript中不同的函数调用方式this 的指向也是不同的

- 全局作用域下的 this指向全局对象，在浏览器中，这个全局对象指向的是windows
- 一般函数中的this,指向的是window

```
function f1(){
    return this;
}
f1()===window;//true

```
- 作为对象方法的函数中的this
  谁调用，this 指向谁。
```
var o = {
    x:1,
    y:function(){
        return this.x;
        //分析：对于属性y 我们定义了一个函数，我们也把这种形式叫做对象的方法.
        //这里的this 指向的是对象 o
        // 因此return this.x 就相当于 return o.x;
    }
}
o.y(); //1

```
再举个例子
```
var o = {prop:37};
function independent(){
    return this.prop;
}
o.f = independent;
console.log(o.f());//37
//分析：这里的this为什么不是window呢？这是因为，在执行过程中，里面的this并不是看函数创建时候的this，而是看函数调用时候的,谁调用了我，我就指向谁。
```


- 对象原型链中的this



构造函数中的this 


call/apply方法与this




bind 方法与this




    


## 字面量
字面量表示如何表达这个值，一般除去表达式，给变量赋值时，等号右边都可以认为是字面量。

字面量分为字符串字面量(string literal )、数组字面量(array literal)和

对象字面量(object literal)，另外还有函数字面量(function literal)。

示例：
var test="hello world!";
"hello world!"就是字符串字面量，test是变量名。


## 匿名函数



## 回调函数
```
function learn(something) {
    console.log(something);
}

function we(callback, something) {
    something += 'is cool';
    callback(something);
}
we(learn, 'Nodejs');//输出  Nodejs id cool
//分析  我们传入进去的是一个具名函数

we(function(something){
    console.log(something)
},'Nodejs');//输出  Nodejs id cool
//分析  我们传入进去的是一个匿名函数

```


## 构造函数

**构造函数介绍**：

构造函数也是一个函数，一般用来创建对象

**构造函数的特征:**

1. 首字母大写 （不大写也没事，但是这是大家规范）
2. 构造函数一般和new 关键字一起使用
3. 不需要手动写返回值

**构造函数执行的过程**

1.1使用new关键字创建对象 

1.2调用构造函数，将构造函数内的this 指向创建出来的对象

1.3 在构造函数内部，通过this给对象新增属性和方法（做初始化工作）

1.4 自动返回刚才new 创建出来的对象

注意：如果手动帮构造函数设置了返回语句呢？

a : 如果返回的是一个简单的数据类型  ，那么没有影响,返回的还是new创建出来的对象

b : 如果返回的是一个复杂的数据类型，则会把创建出来的那个对象给覆盖掉 。返回的是手工设置的数据类型

**new关键字**

ps: 任何函数，只要通过new关键操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过构造函数来调用，那它跟普通函数也没什么两样。

如果像使用普通的函数一样去调用构造函数

 a 函数中的this会指向window对象，通过this添加的所有的属性和方法，都会添加给window对象

  b  函数中如果没有return语句，则返回undefined

**例子：自定义一个构造函数**

```
function my(name,age,sex){	

	this.name = name;

	this.age = age;

	this.sex = sex;

}

```

使用new关键字创建对象
```
var m1 = new My("张", 15,"男");

var m2  = new My("李", 1,"女");
```

构造函数创建对象存在的问题
如果将函数声明放在构造函数里，那么每次创建一个对象，都会拥有这个方法，所有对象的功能方法都一致；从而造成：
1. 资源的一种浪费。功能相同的函数，完全没有必要再内存中存在这么多份。所以就造成了资源浪费。
2. 代码冗余
```
    function Person(name, age){
        this.name = name;
        this.age = age;
        this.sayHi = function(){
            console.log("你好");
        }
    }

    var p = new Person("张三", 18);
    var p1 = new Person("李四", 19);
    console.log(p.sayHi == p1.sayHi); //输出结果为false
```
    构造函数创建对象存在的问题解决办法：

在外部创建一个函数，书写构造函数的时候直接引用，这样的话解决了上述问题，但是又带来了新的问题

```
    function sayHello(){
        console.log("你好");
    }
    
    function Person(name, age){
        this.name = name;
        this.age = age;
        this.sayHi = sayHello;
    }
    
    //调用该构造函数创建对象，并对比创建出来的对象的sayHi方法
    var p = new Person("张三", 18);
    var p1 = new Person("李四", 19);
    console.log(p.sayHi == p1.sayHi); //输出结果为true
    
```

**构造函数存在的问题解决办法--新的问题**

- 全局变量增多，会增加引入框架命名冲突的风险
- 代码结构混乱，会变得难以维护


**构造函数存在的问题解决办法**

引入原型




## 函数(值类型的数据作为函数的参数)的调用过程 


```
 function test1(num) {
      num = 100;
    }
    var num1 = 10;
    test1(num1);
    console.log(num); //is not defined
    console.log(num1); //10
    //分析过程
    1 num1 在内存中声明一个空间 赋值为 10 
    2 函数调用  函数有形参，会先声明，并把实参的值赋值给他，num=10
    3 执行函数 num =100;
    4 执行完之后空间回收，所以num已经不存在,
    5 所以最后 num1 输出的值是 10 
```

## 函数(引用类型的数据作为函数的参数)的调用过程 
```
 function test2(arr){
       arr[0] = 100;
     }
     var arr1 = [10,20,30];
     test2(arr1);             
     console.log(arr1[0]); //100
     //分析过程
     1 在内存中申明一个空间，用来存放数组[10,20,30] 变量 arr1 存放的数组[10,20,30]的地址。
     2 调用函数 test2 ,因为有形参，所以先声明形参。并把存放在arr1中的地址赋值一份给arr
     3 修改数组arr[0]的值。
     4 回收形参arr的空间
     5 输出arr1[0]的值 
     
```

## 总结引用类型作为函数的参数和值类型作为函数的参数
    . 引用类型因为指向的是同一个，所以你改一个，另外一个也就跟着改了。
    . 值类型的话就不一样了。两者都是在不同的内存空间中，不会互相影响。


## 函数  高级部分
## 静态成员
由构造函数点出来的属性，我们叫做静态成员。
```
Math.random(); 
Math.abs();

```

## 实例成员
由实例化的对象点出来的属性，我们叫实例成员
```
function Person(name){
    this.name = name;
  }
  Person.prototype.sayHi = function () {
    console.log("哈哈哈哈....");
  }
   Person.sayHi();
//这里的sayHi是构造函数作为对象点出来的，所以这里的sayHi就是静态成员。
```

## instancof


## eval函数
可以把字符串当做代码执行，但是字符串要符合js代码规范
```
eval("var a = 10;");
console.log(a);//10

```















 
